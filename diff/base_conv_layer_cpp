diff --git a/src/caffe/layers/base_conv_layer.cpp b/src/caffe/layers/base_conv_layer.cpp
index dccd517..213a7e1 100644
--- a/src/caffe/layers/base_conv_layer.cpp
+++ b/src/caffe/layers/base_conv_layer.cpp
@@ -27,6 +27,12 @@ void BaseConvolutionLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
       && conv_param.has_stride_w())
       || (!conv_param.has_stride_h() && !conv_param.has_stride_w()))
       << "Stride is stride OR stride_h and stride_w are required.";
+  CHECK((!conv_param.has_kstride() && conv_param.has_kstride_h()
+      && conv_param.has_kstride_w())
+      || (!conv_param.has_kstride_h() && !conv_param.has_kstride_w()))
+      << "KStride is kstride OR kstride_h and kstride_w are required.";
+
+
   if (conv_param.has_kernel_size()) {
     kernel_h_ = kernel_w_ = conv_param.kernel_size();
   } else {
@@ -47,10 +53,24 @@ void BaseConvolutionLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
     stride_h_ = conv_param.stride_h();
     stride_w_ = conv_param.stride_w();
   }
+  if (!conv_param.has_kstride_h()) {
+    kstride_h_ = kstride_w_ = conv_param.kstride();
+  } else {
+    kstride_h_ = conv_param.kstride_h();
+    kstride_w_ = conv_param.kstride_w();
+  }
+  if (!(kstride_h_ == 1)) {
+    CHECK_EQ(stride_h_, 1) << "Currently, when using kstride, the stride parameter should be fixed to 1.";
+    CHECK_EQ(stride_w_, 1) << "Currently, when using kstride, the stride parameter should be fixed to 1.";
+  }
+  ext_kernel_h_ = (kernel_h_ - 1) * kstride_h_ + 1;
+  ext_kernel_w_ = (kernel_w_ - 1) * kstride_w_ + 1;
+
+
   // Special case: im2col is the identity for 1x1 convolution with stride 1
   // and no padding, so flag for skipping the buffer and transformation.

